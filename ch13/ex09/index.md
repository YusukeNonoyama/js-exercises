## i1()
### 説明
Promise.any()の引数配列の２つの非同期処理は、先に終わるwait1の値42で満たされる。その後、もう１つの非同期処理が継続されるため、v=100によりPromiseが満たされた返り値が上書きされる。ただし、プロミス自体は既に満たされているので返り値0は無視される。
### 図解
wait1   // 同時に開始する非同期処理１
|-----|
      log42
      |-|
wait2   // 同時に開始する非同期処理２
|----------|
           v=100
           |-|
wait2
|----------|
           log100
           |-|

## i2()
### 説明
全てのプロミスが返った後に結果の配列を返しvに代入。vを出力。
### 図解
wait3   // 同時に開始する非同期処理1
|---------------|
                logA
                |-|
wait2   // 同時に開始する非同期処理2
|----------|
           logB
           |-|
wait1   // 同時に開始する非同期処理3
|-----|
      logC
      |-|
                  log([ 'A', 'B', 'C' ])
                  |-|

## i3()
### 説明
wait1が満たされてerrYにてcatch節が呼ばれる。catch節中のwait3()中に、Promise.all()内のwait3()が終了しv=0に書き換わるがerrXは無視される。その後、catch節のwait3が満たされてlog(0)を出力する。

### 図解
wait3   // 同時に開始する非同期処理1
|---------------|
                v=0代入
                |-|
                  errX => catchされない
                  |-|
wait2   // 同時に開始する非同期処理2
|----------|
           logB
           |-|
wait1   // 同時に開始する非同期処理3
|-----|
      errY => catch => log(e) => log(42)
      |-|
        wait3
        |---------------|
                        log(0)
                　　　　 |-|

### 結果
```
Y
42
B
0
```

## i4()
### 説明
p1とp2の非同期プロセスは１秒毎に交互にvの値を更新しようとするが、nextをvに代入する前にawait wait2()が入るため、直前にもう一方の非同期プロセスがvに加える分はカウントされない。従って10ではなく半分の5が最後に出力される。

### 図解
// p1の処理
wait1
|-----|
      v=0, next=1
      |-|
        wait2
        |----------|
                   v=1, next=2
                   |-|
                     wait2
                     |----------|
                                 v=2, next=3
                                 |-|...
// p2の処理
v=0, next=1
|-|
  wait2
  |----------|
             v=1, next=2
             |-|
               wait2
               |----------|
                          v=2, next=3
                          |-|...
## f3()
### 説明
同期処理でtry節のプロミスが返り、finally節のCが出力される。その後、非同期処理のwait0解決後にAが出力され、wait(0).then(logA)解決後にエラーXが実行されるが同期処理ではcatchされずそのまま終了。
### 図解
wait0
|-|
  logC  // ここまで同期処理
  |-|
    logA  // ここから非同期処理
    |-|
      errX
      |-|

## f4()
### 説明
2秒後にAが出力され、2つ目のthenのコールバックが40を入力として実行されBが出力される。その後、3つ目のthenのコールバックが100を入力としてじっこうされ100が出力される。

### 図解
wait2
|----------|
           logA
           |-|
             wait1
             |-----|
                   logB
                   |-|
                     log(100)
                     |-|


## f5()
### 説明
2つ目のthenの引数が関数ではなくプロミスになっているため、同期処理として直ちに実行される。その後非同期処理の実行で、1つ目のthen解決後にAが出力し40を返し、2つ目のthenは解決既に満たされているため無視され、3つ目のthenで40を入力にしてコールバックが呼ばれ40が出力される。
### 図解
        wait2
        |----------|
                  logA
                  |-|
wait1
|-----| // 同期処理で実行される
      logB
      |-|
                    log(40)
                    |-|

## f6()
### 説明
1秒後にAが出力されてpが満たされると同時に登録されたコールバックが同時に呼ばれるため、1秒後にB、その1秒後にCが出力される。
### 図解
wait1
|-----|
      logA
      |-|
        wait1
        |-----|
              logB
              |-|
        wait2
        |----------|
                    logC
                    |-|
                    
## f7()
### 説明
同期処理でwait1とwait2はほぼ同時に開始される。wait1().then(logA)が解決した後、pは既に解決満たされているためp.then(logB)は直ちに実行され、その後Ｃが出力される。
### 図解
wait1
|-----|
      logA
      |-|
wait2
|----------|
           logB // 直ちに実行される
           |-|
             logC
             |-|            
    

## f8()
### 説明
1秒後にerrXをthrowし、catch節までプロミスチェーンを下りエラーを出力。最後にfinally節のAを出力する。
### 図解
wait1
|-----|
      errX
      |-|
        errXの表示
        |-|
          logA
          |-|   


## f9()
### 説明
### 図解

## f10()
### 説明
### 図解

## f11()
### 説明
### 図解

## f12()
### 説明
### 図解
## f3()

### 説明

同期処理でtry節のプロミスが返り、finally節のCが出力される。その後、非同期処理のwait0解決後にAが出力され、wait(0).then(logA)解決後にエラーXが実行されるが同期処理ではcatchされずそのまま終了。

### 図解

wait0
|-|
logC // ここまで同期処理
|-|
logA // ここから非同期処理
|-|
errX
|-|

## f4()

### 説明

2秒後にAが出力され、2つ目のthenのコールバックが40を入力として実行されBが出力される。その後、3つ目のthenのコールバックが100を入力としてじっこうされ100が出力される。

### 図解

wait2
|----------|
logA
|-|
wait1
|-----|
logB
|-|
log(100)
|-|

## f5()

### 説明

2つ目のthenの引数が関数ではなくプロミスになっているため、同期処理として直ちに実行される。その後非同期処理の実行で、1つ目のthen解決後にAが出力し40を返し、2つ目のthenは解決既に満たされているため無視され、3つ目のthenで40を入力にしてコールバックが呼ばれ40が出力される。

### 図解

        wait2
        |----------|
                  logA
                  |-|

wait1
|-----| // 同期処理で実行される
logB
|-|
log(40)
|-|

## f6()

### 説明

1秒後にAが出力されてpが満たされると同時に登録されたコールバックが同時に呼ばれるため、1秒後にB、その1秒後にCが出力される。

### 図解

wait1
|-----|
logA
|-|
wait1
|-----|
logB
|-|
wait2
|----------|
logC
|-|

## f7()

### 説明

同期処理でwait1とwait2はほぼ同時に開始される。wait1().then(logA)が解決した後、pは既に解決満たされているためp.then(logB)は直ちに実行され、その後Ｃが出力される。

### 図解

wait1
|-----|
logA
|-|
wait2
|----------|
logB // 直ちに実行される
|-|
logC
|-|

## f8()

### 説明

1秒後にerrXをthrowし、catch節までプロミスチェーンを下りエラーを出力。最後にfinally節のAを出力する。

### 図解

wait1
|-----|
errXをthrow
|-|
errXの表示
|-|
logA
|-|

## f9()

### 説明

1つ目のthenのコールバック関数は何も表示せず、次のthenでerrYをthrowする。catch節までプロミスチェーンを下りエラーを出力。最後にfinally節のAを出力する。

### 図解

wait1
|-----|
errYをthrow
|-|
errYの表示
|-|
logA
|-|

## f10()

### 説明

errYをthrowした後にcatch節がないためエラーで終了する。then(r).then(f, c) と then(r).catch(c)が等しい。

### 図解

wait1
|-----|
errYをthrow
|-|
logA
|-|  
 errorの表示
|-|

## f11()

### 説明

前のプロミスで発生したエラーはプロミスチェーンを下ってcatchされる。

### 図解

errXをthrow
|-|  
 errXを表示
|-|

## f12()

### 説明

### 図解

// 1. bを負数表現とすることでa と complement_b の足し算の問題に帰結
// 2. アルゴリズム
//   bit桁毎の足し算は繰り上がりを無視すればビット排他的論理和演算(^)で決まる(=> c)
//   - 0と0 => 0
//   - 0と1 または 1と0 => 1
//   - 1と1 => 0 (次の位に繰り上がり)
//   繰り上がりで足される数は以下の通りに算出できる
//   - 繰り上がりが必要な桁をビット積演算(&)で抽出
//   - 抽出した2進数について左に1つシフト(<<)した2進数を求める(=> d)
//   求めたい和はcとdの足し算として表現できるため、これを再帰的に演算してdが0となる時のcをreturn
// 3. バイナリでマイナスサインをついた表現を避けるために">>> 0"を適宜追加
//    ※例えば-5の表現を'11111111111111111111111111111011'にしたいのに'-101'になってしまう
//    ※全て4の表現でも算出できるがバイナリ数にもマイナス符号が付き考えにくかった
// 4. 最終出力は符号付きの32-bit表現に強制するため"| 0"を追加

// 再帰的に足し算をする関数
function add(a, b) {
  // 繰り上がりを無視した演算（ビット排他的論理和演算）
  let c = (a ^ b) >>> 0;
  // let c = (a ^ b) | 0;
  console.log("c: ", c.toString(2));
  // 繰り上がりで加算が必要な数の算出（ビット積演算結果を1つ左にシフト）
  let d = (((a & b) >>> 0) << 1) >>> 0;
  console.log("d: ", d.toString(2));

  // dが0でなければ再帰的に演算
  if (d !== 0) {
    return add(c, d);
  }
  return c | 0;
}

// bの負数表現を算出して足し算を再帰的に呼び出す
export function sub(a, b) {
  let negative_b = (~b + 1) >>> 0;
  console.log("a: ", a.toString(2));
  console.log("b: ", b.toString(2));
  console.log("negative_b: ", negative_b.toString(2));
  console.log("start recurse...");
  return add(a, negative_b);
}

// console.log(sub(8, 100));
console.log(sub(8, 100));

// 実行コマンド： node ch04/ex03/index.js

// 計算：　sub(8, 3)

// a:  1000
// b:  11
// negative_b:  11111111111111111111111111111101
// start recurse...
// c:  11111111111111111111111111110101
// d:  10000
// c:  11111111111111111111111111100101
// d:  100000
// c:  11111111111111111111111111000101
// d:  1000000
// c:  11111111111111111111111110000101
// d:  10000000
// c:  11111111111111111111111100000101
// d:  100000000
// c:  11111111111111111111111000000101
// d:  1000000000
// c:  11111111111111111111110000000101
// d:  10000000000
// c:  11111111111111111111100000000101
// d:  100000000000
// c:  11111111111111111111000000000101
// d:  1000000000000
// c:  11111111111111111110000000000101
// d:  10000000000000
// c:  11111111111111111100000000000101
// d:  100000000000000
// c:  11111111111111111000000000000101
// d:  1000000000000000
// c:  11111111111111110000000000000101
// d:  10000000000000000
// c:  11111111111111100000000000000101
// d:  100000000000000000
// c:  11111111111111000000000000000101
// d:  1000000000000000000
// c:  11111111111110000000000000000101
// d:  10000000000000000000
// c:  11111111111100000000000000000101
// d:  100000000000000000000
// c:  11111111111000000000000000000101
// d:  1000000000000000000000
// c:  11111111110000000000000000000101
// d:  10000000000000000000000
// c:  11111111100000000000000000000101
// d:  100000000000000000000000
// c:  11111111000000000000000000000101
// d:  1000000000000000000000000
// c:  11111110000000000000000000000101
// d:  10000000000000000000000000
// c:  11111100000000000000000000000101
// d:  100000000000000000000000000
// c:  11111000000000000000000000000101
// d:  1000000000000000000000000000
// c:  11110000000000000000000000000101
// d:  10000000000000000000000000000
// c:  11100000000000000000000000000101
// d:  100000000000000000000000000000
// c:  11000000000000000000000000000101
// d:  1000000000000000000000000000000
// c:  10000000000000000000000000000101
// d:  10000000000000000000000000000000
// c:  101
// d:  0
// 5

// 計算：　sub(8, 100)

// a:  1000
// b:  1100100
// negative_b:  11111111111111111111111110011100
// start recurse...
// c:  11111111111111111111111110010100
// d:  10000
// c:  11111111111111111111111110000100
// d:  100000
// c:  11111111111111111111111110100100
// d:  0
// -92
